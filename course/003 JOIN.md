![image](https://github.com/user-attachments/assets/bd82951a-abbd-4d4c-9079-3ad9ee02edb9)


## [1] Мир нескольких табличек

Мы уже успели поработать с одной табличкой, но в реальности табличек много.

Множество табличек хранится в базе данных (Postgres/MySQL/Oracle и другие названия БД (хотя на самом деле правильнее СУБД - систем управления базами данных, ибо в одной системе может быть даже несколько баз данных) могут вам встретится в будущем, но самое популярное на данный момент - это Postgres, хотя на самом деле это даже GreenPlum, но о нем стоит читать только если вы хотите заснуть или вам некуда девать свое свободное время) 

Хотя на самом деле все еще интереснее, ибо есть еще так называемые слои данных (как слоенный американский пирог) 

Например:
1. Слой с данными по маркетинговым акциям
2. Слой с данными по грузоперевозкам
3. Слой с персональными данными пользователей
4. И так далее

Обычно организация табличек в слои сделано с целью удобства, ну это как сортировать свои носки, чтобы они не были разбросаны по комнате 

Представь, что ты пошел работать в какую-нибудь небольшую контору, которая занимается производством пивных крышек, так вот они дали тебе доступ к одной из своих баз данных, которая реализована на Postgres'e

Тогда что ты можешь потенциально увидеть через тот же самый DBeaver, когда к ней подключишься ->

![image](https://github.com/user-attachments/assets/7e913b79-a0a3-4c4f-b6dc-3a94315c8865)

И вот тут возникает вопрос - а как таблицы могут взаимодействовать друг с другом в рамках одного SELECT запроса?

Ведь (мало ли) понадобится посмотреть количество отгруженных товаров по списку контрагентов, который вообще хранится в другой таблице?

На помощь приходит конструкция JOIN 

Но мы попробуем ее изучить немного с неклассической стороны, ибо обычно начинают изучать её с INNER JOIN'a

Я же предлагаю начать изучать с CROSS JOIN'a и позже, надеюсь, ты поймешь - почему 


## [2] CROSS JOIN - батя всех видов JOIN'ов

Есть следующие виды JOIN'ов в стандартном SQL: INNER, LEFT (RIGHT, это как лефт, только наоборот), FULL, CROSS 

Знакомимся сначала на конкретном примере с CROSS JOIN 

Пусть у нас есть следующие таблички 

Первая табличка A

| 1 |
|---|
| 2 |

И вторая таблица B

| 3 |
|---|
| 4 |

У каждой один столбец (неважно, как он называется) и две строчки

Посмотрим на результат запроса 

SELECT *
FROM A 
CROSS JOIN B

| 1 | 3 |
|---|---|
| 2 | 3 |
| 1 | 4 |
| 2 | 4 |

Думаю, вы догадались, что делает CROSS JOIN, но я объясню: он к каждой строчке из первой таблицы присоединяет каждую строчку из второй таблицы 

Есть специфичный тип задач, для которых этот тип джоина нужен, но на собесах он встречается крайне редко

Давайте уже поговорим с того типа JOIN'а, с которого обычно начинают изучение всех JOIN'ов 

## [3] INNER JOIN - да, это классика

Сразу погнали смотреть пример

Первая табличка A

| 1 |
|---|
| 2 |

И вторая таблица B

| 2 |
|---|
| 4 |

У каждой один столбец под название col и две строчки

Посмотрим на результат запроса 

SELECT *
FROM A 
INNER JOIN B
ON A.col = B.col

| A.col  | B.col |
|---|---|
| 2 | 2 |

То есть INNER JOIN оставляет только те строчки, в которых условие ON выполняется (выдает TRUE - это как фильтровать строчки в WHERE)

Но на самом деле для простоты запоминания, вы можете представить себе INNER JOIN как CROSS JOIN + WHERE 

SELECT *
FROM A 
CROSS JOIN B
WHERE A.col = B.col

То есть по умолчанию (это не совсем правда и многое зависит от конкретной базы данных) производится join каждой строчки к каждой, а потом уже такие сформированные пары фильтруются по условию в ON 

Едем дальше -> LEFT JOIN 

## [4] LEFT JOIN  - не соединяет сердца, но "справочники"

Снова начинаем сразу с примера


Первая табличка A

| 1 |
|---|
| 2 |

И вторая таблица B

| 2 |
|---|
| 4 |

У каждой один столбец под название col и две строчки

Посмотрим на результат запроса 

SELECT *
FROM A 
LEFT JOIN B
ON A.col = B.col

| A.col  | B.col |
|---|---|
| 1 | NULL |
| 2 | 2 |


Что же произошло: LEFT JOIN добавил данные по условию ON к исходной таблице, но если данных не нашлось - то оставил так называемый NULL - специальное значение, которое обозначает отсутствие данных 

Как можно описать LEFT JOIN? По сути результат LEFT JOIN'a = результат INNER JOIN'a + добавление тех строчек из исходной таблицы "A", к которым ничего не присоединилось

Да, кстати, чаще всего LEFT JOIN вы можете увидеть в реальной жизни и на собеседованиях, ибо с помощью него присоединяют некие "справочники" к "таблицам-фактам"

Сразу на примере давайте смотреть: пусть у вас есть таблица с заказами на каком-нибудь маркетплейсе и список ID использований различных промокодов на заказ - это будет "табличка-фактов", ибо в нее записывается какой-то произошедший факт в реальной жизни - покупка на маркетплейсе. А есть табличка "справочник" по промокодам, в котором находится список с описанием всех промокодов. И его как раз left'ят к основной таблице, чтобы дополнить информацию о ней

А почему именно LEFT?

Да потому, что в реальной жизни может просто не обновили актуальный справочник и при INNER JOIN'e вы потеряете часть заказов и ваш анализ будет неточным

На собесах любят ловить с таким моментом, так что будьте аккуратны 

## [5] Big babby table 

А давайте хранить сразу все в одной таблице! 

И тогда JOIN'ы не нужны будут! 

(с) Джейсон Стетхем 


На самом деле это тема про нормализацию и денормализацию таблиц 

Пока я не собираюсь глубого это здесь освещать, но если кратко, то есть два путя:

1. Путь 1 - раскидать данные на столько табличек, насколько это возможно. Тогда вес данных будет минимально возможен, но для аналитики будет не так удобно, ибо нужно будет JOIN'ить данные, а делать JOIN'ы дорого как по памяти компьютера, так и по его скорости
2. Путь 2 - сразу делать монстра в виде одной огромной таблицы. Ничего JOIN'ить не нужно, но есть проблемка - будет неоптимальное хранение данных из-за дублей...

А че еще за дубли? 

На самом деле с этого момента тема дублей вас будет сопровождать до окончания вашего использования SQL

На работе, на собеседованиях, везде при упоминании JOIN'ов вы будете вспомнить их - дубли

А при первом изучении у вас будут наворачиваться слезы от непонимания этой фигни

Но это нормально, все получится, так что погнали дальше 

Следите за руками: 

Пусть есть табличка с заказами 

| Номер заказа (уникальный) | Уникальный ID промокода, использованного в заказе|
|---|---|
| 1 | 1 |
| 2 | 1 |

И табличка с промиками

| Уникальный ID промокода | Описание промика |
|---|---|
| 1 | "Скидка 15% на крем для ушей" |

и если бы мы хранили все сразу в одной таблице, то 

| Номер заказа (уникальный) | Уникальный ID промокода, использованного в заказе|  Описание промика |
|---|---|---|
| 1 | 1 | "Скидка 15% на крем для ушей" |
| 2 | 1 | "Скидка 15% на крем для ушей" |

А ведь под этот текст выделяется память в БД, за которую платит компания, а это бабки, а бабки на дороге не валяются 

Но с дублями мы еще поразвлекаемся, но попозже 

## [6] FULL JOIN - олл ин клюзив в мире джоинов 

Я еще же не рассказал про FULL - исправляюсь

Представьте, что вы хотите сказать SQL че-то вроде такой команды: "те пары, которые по условию ON совпадают - заджоинь, а оставшиеся TRUE условия в ON строчки из таблицы A и таблицы B - тоже докинь в результат, но, соответственно, с NULL'ами"

Смотрим пример

Первая табличка A

| 1 |
|---|
| 2 |

И вторая таблица B

| 2 |
|---|
| 4 |

У каждой один столбец под название col и две строчки

Посмотрим на результат запроса 

SELECT *
FROM A 
FULL JOIN B
ON A.col = B.col

| A.col  | B.col |
|---|---|
| 1 | NULL |
| 2 | 2 |
| NULL | 4 |

По сути, это результат LEFT JOIN'а + строчки, которые остались в таблице B 

## [7] JOIN работает не только по "ключам"

На самом деле у каждой таблицы должен быть уникальной идентификатор строки, так называемый первичный ключ

Вы где-то может даже слышали еще о понятии, как внешний ключ или что-то в этом духе, по которому можно заджоинить таблицу с другой таблицей

Например, внешним ключем в таблице с заказами был айди промокода, тогда как уже в таблице с промокодами айди промокода - это уже первичный ключ (спасибо, капитан очевидность)

И прикол в том, что на многих курсах все видят примеры, как джоинят именно по этим ключам

Да и в реальной жизни джоинят зачастую по ключам

Ведь это просто логично - зачем еще как-то по-другому джоинить?

Но вот тут та и начинаются приколы, ибо на собесе вас могу запросто спросить "а можно ли заджоинить по условию ON 9 > 0"? 

И вы такие читаете этот вопрос и такие 

![image](https://github.com/user-attachments/assets/fc1d614a-eda4-4fcb-8463-69269d141b4b)




